// Generated by CoffeeScript 1.10.0
(function() {
  var Association, _, async, convertType, handleError, makeOperation, parseValues, ref;

  async = require('async');

  _ = require('underscore');

  ref = require('./common'), makeOperation = ref.makeOperation, handleError = ref.handleError;

  Association = require('./association');

  convertType = function(value) {
    if (value === 'undefined') {
      return void 0;
    }
    if (value === 'null') {
      return null;
    }
    if (value === 'true') {
      return true;
    }
    if (value === 'false') {
      return false;
    }
    return value;
  };

  parseValues = function(values) {
    Object.keys(values).map(function(valueKey) {
      return values[valueKey] = convertType(values[valueKey]);
    });
    return values;
  };

  module.exports = function(model, include) {
    var create, del, list, read, update, updateMultiple;
    create = makeOperation(function(values, done) {
      var query;
      query = query || {};
      if ((include != null) && (query.include == null)) {
        query.include = include;
      }
      values = parseValues(values);
      return async.waterfall([
        function(done) {
          return model.create(values).then(function(data) {
            return Association.attempt(model, data, values, done);
          })["catch"](function(err) {
            return handleError(err, done);
          });
        }, function(data, done) {
          query.where = {};
          query.where[model.primaryKeyField] = data[model.primaryKeyField];
          return model.find(query).then(function(data) {
            return done(null, data);
          });
        }
      ], function(err, data) {
        return done(err, data);
      });
    });
    list = makeOperation(function(options, done) {
      var query;
      query = options || {};
      if ((include != null) && (options.include == null)) {
        query.include = include;
      }
      if ((options.filter != null) && (options.filterBy != null)) {
        query.where = {};
        query.where[options.filterBy] = options.filter;
      }
      if ((options.limit != null) && (options.offset != null)) {
        query.limit = +options.limit;
        query.offset = +options.offset;
      }
      if ((options.sort != null) && (options.sortBy != null)) {
        query.order = options.sortBy + ' ' + options.sort;
      }
      return model.findAll(query).then(function(data) {
        return done(null, data);
      })["catch"](function(err) {
        return handleError(err, done);
      });
    });
    read = makeOperation(function(query, done) {
      if (query.where == null) {
        query = {
          where: query
        };
      }
      if ((include != null) && (query.include == null)) {
        query.include = include;
      }
      return model.find(query).then(function(data) {
        return done(null, data);
      })["catch"](function(err) {
        return handleError(err, done);
      });
    });
    update = makeOperation(function(query, values, done) {
      var updateValues;
      if (query.where == null) {
        query = {
          where: query
        };
      }
      if ((include != null) && (query.include == null)) {
        query.include = include;
      }
      updateValues = parseValues(_.omit(values, function(value, key) {
        return /\w+\.(set|add|remove)/.test(key);
      }));
      return async.waterfall([
        function(done) {
          if (_.isEmpty(updateValues)) {
            return done();
          }
          return model.update(updateValues, query).then(function(data) {
            return done(null);
          })["catch"](function(err) {
            return handleError(err, done);
          });
        }, function(done) {
          return model.find(query).then(function(data) {
            return Association.attempt(model, data, values, function() {
              return done();
            });
          })["catch"](function(err) {
            return handleError(err, done);
          });
        }, function(done) {
          return model.find(query).then(function(data) {
            return done(null, data);
          });
        }
      ], function(err, data) {
        return done(err, data);
      });
    });
    updateMultiple = makeOperation(function(values, done) {
      var updateValue;
      updateValue = function(value, done) {
        var parsedValues;
        parsedValues = parseValues(_.omit(value, function(val, key) {
          return /\w+\.(set|add|remove)/.test(key);
        }));
        return async.waterfall([
          function(done) {
            return model.update(parsedValues, {
              where: {
                id: value.id
              }
            }).then(function(data) {
              return done(null);
            })["catch"](function(err) {
              return handleError(err, done);
            });
          }, function(done) {
            return model.find({
              where: {
                id: value.id
              }
            }).then(function(data) {
              return Association.attempt(model, data, value, function() {
                return done();
              });
            })["catch"](function(err) {
              return handleError(err, done);
            });
          }, function(done) {
            var query;
            query = {
              where: {
                id: value.id
              }
            };
            if ((include != null) && (query.include == null)) {
              query.include = include;
            }
            return model.find(query).then(function(data) {
              return done(null, data);
            });
          }
        ], function(err, data) {
          return done(err, data);
        });
      };
      return async.map(values, updateValue, done);
    });
    del = makeOperation(function(query, done) {
      if (query.where == null) {
        query = {
          where: query
        };
      }
      return model.destroy(query).then(function(data) {
        return done(null, data);
      })["catch"](function(err) {
        return handleError(err, done);
      });
    });
    return {
      create: create,
      list: list,
      read: read,
      update: update,
      updateMultiple: updateMultiple,
      del: del
    };
  };

}).call(this);
